/*
	Copyright 2017 Northeastern University

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

	  http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/
package batch.dao;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;
import org.springframework.stereotype.Repository;

import batch.service.dto.BatchLogEntryDTO;

/**
 * Database insulation layer for Batch log table; uses Spring Jdbc.
 * @author Joseph Sackett
 */
@Repository
public class BatchDAO {
	/** Logger. */
	private static final Logger logger = LogManager.getLogger(BatchDAO.class);
	/** Converts String to/from Date. */
	private static final DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");

	/** Spring Jdbc for executing SQL. */
    private JdbcTemplate jdbcTemplate;
	/** Spring batch log Jdbc insert wrapper. */
	private SimpleJdbcInsert jdbcInsertBatchLog;
	/** Spring Image Jdbc insert wrapper. */
	private SimpleJdbcInsert jdbcInsertImage;

	/** Initializes Spring Jdbc. */
    @Autowired
    public void setDataSource(final DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
        this.jdbcInsertBatchLog = new SimpleJdbcInsert(dataSource)
                .withTableName("batchlog")
                .usingGeneratedKeyColumns("id")
                .usingColumns("job", "description","created");
        this.jdbcInsertImage = new SimpleJdbcInsert(dataSource)
                .withTableName("image")
                .usingGeneratedKeyColumns("id");
    }

    /** Insert into image table; return autogenerated id. */
    public int insertImage(final String name) {
        final Map<String, Object> parms = new HashMap<>();
        parms.put("name", name);
        return jdbcInsertImage.executeAndReturnKey(parms).intValue();
    }

	/** Creates a new new batch log entry, returns Id. */
	public int createBatchLogEntry(final String job, final String description) {
		final Map<String, Object> parms = new HashMap<>();
        parms.put("job", job);
        parms.put("description", description);
		Calendar calendar = Calendar.getInstance();
		String currentTime = dateFormat.format(calendar.getTime());
		logger.info(currentTime);
		parms.put("created", currentTime);
	    return jdbcInsertBatchLog.executeAndReturnKey(parms).intValue();
	}

	/** Read all batch log entries. */
	public List<BatchLogEntryDTO> readBatchLogEntries() {
		return jdbcTemplate.query("select id, job, description, created from batchlog order by created",
	        (RowMapper<BatchLogEntryDTO>) (rs, rowNum) -> {
				try {
					return new BatchLogEntryDTO(rs.getInt("id"), rs.getString("job"), rs.getString("description"), dateFormat.parse(rs.getString("created")));
				} catch (final ParseException e) {
					logger.error("", e);
					return null;
				}
	        });
	}

	/** Creates batch log tables. */
	public void createBatchSchema() {
		String sql = "drop table if exists batchlog";
		jdbcTemplate.update(sql);
		logger.trace("Dropped BATCHLOG table.");

		sql = "create table batchlog " +
			"(id 			integer 	primary key autoincrement 	not null, " +
			"job			text 		not null, " +
			"description	text 		not null, " +
			"created        text    not null)";
		jdbcTemplate.update(sql);
		logger.trace("Created BATCHLOG table.");
	}

//    /** SQL for reading list of traces. */
//    private static final String readTraceListSql = "select id, name from trace t where image_id = %d";
//
//	public List<Trace> readTraceList(final int imageId) {
//    	final String sql = String.format(readTraceListSql, imageId);
//    	final TraceListRowCallbackHandler handler = new TraceListRowCallbackHandler(imageId);
//    	jdbcTemplate.query(sql, handler);
//    	return handler.getTraces();
//    }
//
//    /** Handler implements RowCallbackHandler to read list of traces. */
//    private static class TraceListRowCallbackHandler implements RowCallbackHandler {
//		/** Current Image id. */
//    	private final int imageId;
//		/** Return value. */
//    	private final List<Trace> traces = new LinkedList<>();
//
//    	/** Constructor Image id. */
//    	public TraceListRowCallbackHandler(final int imageId) {
//			super();
//			this.imageId = imageId;
//		}
//
// 		/** Read result set; RowCallbackHandler interface. */
//        @Override
//        public void processRow(final ResultSet rs) throws SQLException {
//    	   	final int id = rs.getInt("id");
//    		final String name = rs.getString("name");
//    	   	traces.add(new Trace(id, name, imageId, "#" + String.format("%06x", traceColors[id % NUM_COLORS])));
//        }
//
//    	public List<Trace> getTraces() {
//			return traces;
//		}
//    }
//
//    /** SQL for reading traces within bounding box. */
//    private static final String readTracesSql = "select t.id as trace_id, t.name, e.id as edge_id, e.v1_id, v1.x as v1_x, v1.y as v1_y, v1.z as v1_z, e.v2_id, v2.x as v2_x, v2.y as v2_y, v2.z as v2_z "
//    		+ "from trace t left outer join edge e on t.id = e.trace_id "
//    		+ "inner join vertex v1 on e.v1_id = v1.id "
//    		+ "inner join vertex v2 on e.v2_id = v2.id "
//			+ "where t.image_id = %d and (t.id = %d or (%s ((v1.x >= %d and v1.x <= %d and v1.y >= %d and v1.y <= %d %s) or (v2.x >= %d and v2.x <= %d and v2.y >= %d and v2.y <= %d %s)))) "
//    		+ "order by t.id";
//
//    /** Reading traces within bounding box defined by query. */
//    public List<Trace> readTraces(final TraceImageRangeQueryDTO query) {
//    	final String sql = String.format(readTracesSql, query.getImageId(), query.getCurrTraceId(), sqlifyTraceList(query.getVisibleTraceIds()), query.getxStart(), query.getxEnd(), query.getyStart(), query.getyEnd(),
//		sqlifyTraceZRange("and v1.z >= %d and v1.z <= %d", query.getzStart(), query.getzEnd()), query.getxStart(), query.getxEnd(), query.getyStart(), query.getyEnd(), sqlifyTraceZRange("and v2.z >= %d and v2.z <= %d", query.getzStart(), query.getzEnd()));
//
//    	final TraceRowCallbackHandler handler = new TraceRowCallbackHandler(query.getCurrTraceId(), query.getImageId());
//    	logger.trace(sql);
//    	jdbcTemplate.query(sql, handler);
//    	return handler.getTraces();
//    }
//
//    /** Builds traces from result set. */
//    private static class TraceRowCallbackHandler implements RowCallbackHandler {
//    	/** Current trace id. */
//    	private final int currentTraceId;
//    	/** Current image id. */
//    	private final int imageId;
//    	/** Result traces. */
//    	private final LinkedList<Trace> traces = new LinkedList<>();
//    	/** Flags whether current trace returned. */
//    	private boolean foundSessionTrace = false;
//    	/** Trace currently being built. */
//    	private Trace currTrace = null;
//
//    	/** Constructor takes current trace and Image id. */
//    	public TraceRowCallbackHandler(final int currentTraceId, final int imageId) {
//			super();
//			this.currentTraceId = currentTraceId;
//			this.imageId = imageId;
//		}
//
//    	/** Builds trace from successive rows. */
//		@Override
//		public void processRow(final ResultSet rs) throws SQLException {
//    		final int traceId = rs.getInt("trace_id");
//    		final String traceName = rs.getString("name");
//    		if (currTrace == null || traceId != currTrace.getId()) {
//    			if (traceId == currentTraceId) {
//    				// Trace for this session; place first in list with default color.
//    				currTrace = new Trace(traceId, traceName, imageId, "#FFFF00");
//    				traces.addFirst(currTrace);
//    				foundSessionTrace = true;
//    			}
//    			else {
//    				// Not trace for this session; place later in list with its assigned color.
//    				currTrace = new Trace(traceId, traceName, imageId, "#" + String.format("%06x", traceColors[traceId % NUM_COLORS]));
//    				traces.addLast(currTrace);
//    			}
//    		}
//    		final Edge edge = new Edge(rs.getInt("edge_id"), rs.getInt("v1_id"), rs.getInt("v2_id"));
//    		final Vertex v1 = new Vertex(rs.getInt("v1_id"), rs.getInt("v1_x"), rs.getInt("v1_y"), rs.getInt("v1_z"));
//    		final Vertex v2 = new Vertex(rs.getInt("v2_id"), rs.getInt("v2_x"), rs.getInt("v2_y"), rs.getInt("v2_z"));
//    		currTrace.getEdges().add(edge);
//    		currTrace.getVertices().add(v1);
//    		currTrace.getVertices().add(v2);
// 		}
//
//		/** Return traces built from query. */
//		public LinkedList<Trace> getTraces() {
//			// Add empty default trace if not found.
//			if (!foundSessionTrace) {
//				traces.addFirst(new Trace(currentTraceId, "", imageId, "#FFFF00"));
//			}
//			return traces;
//		}
//    }
//
//    /** SQL to read existing trace from DB. */
//    private static final String sqlReadTrace = "select t.name, t.image_id, v.id as vertex_id, v.x, v.y, v.z, e.id as edge_id, e.v1_id, e.v2_id from trace t left outer join vertex v on t.id = v.trace_id left outer join edge e on ((v.id = e.v1_id and e.v2_id >= e.v1_id) or (v.id = e.v2_id and e.v1_id >= e.v2_id)) where t.id = ? order by t.id, v.id";
//
//	/** Loads a Trace from DB, given Id; throws exception if trace does not exist. */
//	public Trace readTrace(final int imageId, final int traceId) {
//		return jdbcTemplate.queryForObject(sqlReadTrace, new Object[] {traceId},
//	        (rs, rowNum) -> {
//				final Trace t = new Trace(traceId, rs.getString("name"), rs.getInt("image_id"), "#" + Integer.toHexString(traceColors[traceId % NUM_COLORS]));
//		    	int currVertexId = -1;
//				do {
//		    		final int vertexId = rs.getInt("vertex_id");
//		    		if (vertexId != currVertexId) {
//		    			// Add vertex to current trace if not already there, depends on order by in SQL.
//		        		currVertexId = vertexId;
//		        		t.addVertex(new Trace.Vertex(vertexId, rs.getInt("x"), rs.getInt("y"), rs.getInt("z")));
//		    		}
//		    		final int edgeId = rs.getInt("edge_id");
//		    		if (edgeId != 0) {
//			    		// Add edge to current trace if unique in query results (null/0 -> redundant).
//			    		t.addEdge(new Trace.Edge(edgeId, rs.getInt("v1_id"), rs.getInt("v2_id")));
//		    		}
//				} while (rs.next());
//			    return t;
//			});
//	}
//
//	/** Creates a new Trace, returns Id. */
//	public int createTrace(final String name, final int imageId) {
//		logger.debug("insert into trace (id, name, image_id) values (null, " + name + ", " + imageId + ")");
//		final Map<String, Object> parms = new HashMap<>();
//        parms.put("image_id", imageId);
//        parms.put("name", name);
//	    return jdbcInsertTrace.executeAndReturnKey(parms).intValue();
//	}
//
//	/** Creates a new Vertex, returns Id. */
//	public int createVertex(final int traceId, final Trace.Vertex vertex) {
//		final Map<String, Object> parms = new HashMap<>();
//        parms.put("trace_id", traceId);
//        parms.put("x", vertex.getX());
//        parms.put("y", vertex.getY());
//        parms.put("z", vertex.getZ());
//	    return jdbcInsertVertex.executeAndReturnKey(parms).intValue();
//	}
//
//	/** Creates a new Edge, returns Id. */
//	public int createEdge(final int traceId, final Trace.Edge edge) {
//		final Map<String, Object> parms = new HashMap<>();
//        parms.put("trace_id", traceId);
//        parms.put("v1_id", edge.getV1Id());
//        parms.put("v2_id", edge.getV2Id());
//	    return jdbcInsertEdge.executeAndReturnKey(parms).intValue();
//	}
//
//    /** SQL to delete a trace's edges. */
//	private final static String sqlDeleteTraceEdges = "delete from edge where trace_id = %d";
//
//    /** SQL to delete a trace's vertices. */
//	private final static String sqlDeleteTraceVertices = "delete from vertex where trace_id = %d";
//
//    /** SQL to delete a trace. */
//	private final static String sqlDeleteTrace = "delete from trace where id = %d";
//
//	/** Deletes a Trace (maintaining RI) with given Id. */
//	public void deleteTrace(final int traceId) {
//		String sql = String.format(sqlDeleteTraceEdges, traceId);
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//		sql = String.format(sqlDeleteTraceVertices, traceId);
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//		sql = String.format(sqlDeleteTrace, traceId);
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//	}
//
//    /** SQL to select a maximum vertex id for input trace. */
//	private final static String sqlSelectMaxVertex = "select max(id) from vertex where trace_id = ?";
//
//    /** Returns the maximum vertex id for input trace id. */
//    public int readMaxVertexId(final int traceId) {
//		return jdbcTemplate.queryForObject(sqlSelectMaxVertex, new Object[] {traceId}, Integer.class);
//    }
//
//    /** SQL to select a Vertex matching input id. */
//	private final static String sqlSelectVertex = "select id, x, y, z from vertex where id = ?";
//
//	/** Reads a Vertex matching input id. */
//	public Vertex readVertex(final int vertexId) {
//		return jdbcTemplate.queryForObject(sqlSelectVertex, new Object[] {vertexId},
//	        (rs, rowNum) -> {
//	        	return new Vertex(vertexId, rs.getInt("x"), rs.getInt("y"), rs.getInt("z"));
//			});
//	}
//
//    /** SQL to select the trace id for a vertex. */
//	private final static String sqlSelectTraceId = "select trace_id from vertex where id = ?";
//
//	/** Lookup trace id for a vertex. */
//	public int readTraceId(final Vertex vertex) {
//		return jdbcTemplate.queryForObject(sqlSelectTraceId, new Object[] { vertex.getId() }, Integer.class);
//	}
//
//	/** SQL to update edges' parent trace id. */
//	private static final String sqlUpdateEdges = "update edge set trace_id = %d where trace_id = %d";
//
//	/** SQL to update vertices' parent trace id. */
//	private static final String sqlUpdateVertices = "update vertex set trace_id = %d where trace_id = %d";
//
//	/** Update parent trace id of edges and vertices. */
//	public void updateTraceId(final int primaryTraceId, final int secondaryTraceId) {
//		String sql = String.format(sqlUpdateEdges, primaryTraceId, secondaryTraceId);
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//		sql = String.format(sqlUpdateVertices, primaryTraceId, secondaryTraceId);
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//	}
//
//	/** SQL to insert an edge. */
//	private static final String sqlInsertEdge = "insert into edge (id, trace_id, v1_id, v2_id) values (null, %d, %d, %d)";
//
//	/** Insert an edge. */
//	public void addEdge(final int primaryTraceId, final Vertex primaryVertex, final Vertex secondaryVertex) {
//		final String sql = String.format(sqlInsertEdge, primaryTraceId, primaryVertex.getId(), secondaryVertex.getId());
//		logger.debug(sql);
//		jdbcTemplate.update(sql);
//	}
//
//	/** Writes delta SQL statements to DB. */
//	public void commitDeltas(final List<String> sqlDeltas) {
//		for (final String sql : sqlDeltas) {
//			logger.debug(sql);
//			jdbcTemplate.update(sql);
//		}
//	}
//
//	/** Creates trace tables. */
//    public void createTraceSchema() {
//		String sql = "drop table if exists edge";
//		jdbcTemplate.update(sql);
//		sql = "drop table if exists vertex";
//		jdbcTemplate.update(sql);
//		sql = "drop table if exists trace";
//		jdbcTemplate.update(sql);
//		logger.trace("Dropped TRACE, VERTEX and EDGE tables.");
//
//		sql = "create table trace " +
//			"(id integer primary key autoincrement not null, " +
//			"name 		text 	not null, " +
//			"image_id 	integer not null)";
//		jdbcTemplate.update(sql);
//		logger.trace("Created TRACE table.");
//
//		sql = "create table vertex " +
//			"(id integer primary key autoincrement not null, " +
//			"trace_id integer not null, " +
//			"x integer not null, " +
//			"y integer not null, " +
//			"z integer not null)";
//		jdbcTemplate.update(sql);
//		logger.trace("Created VERTEX table.");
//
//
//		sql = "create table edge " +
//			"(id integer primary key autoincrement not null, " +
//			"trace_id integer not null, " +
//			"v1_id integer not null, " +
//			"v2_id integer not null)";
//		jdbcTemplate.update(sql);
//		logger.trace("Created EDGE table.");
//    }
//
//    /** Turns list of traces ids into format for set comparison. */
//    private static String sqlifyTraceList(final List<Integer> traceIds) {
//    	if (traceIds == null) {
//    		// Will return not consider trace_id in query, returning all.
//    		return "";
//    	}
//    	else if (traceIds.isEmpty()) {
//    		// Force no result traces.
//    		return "t.id < 0 and";
//    	}
//
//    	String result ="(";
//    	boolean first = true;
//    	for (final Integer traceId : traceIds) {
//    		if (first) {
//    			first = false;
//    		}
//    		else {
//    			result += ",";
//    		}
//    		result += traceId;
//    	}
//    	result += ")";
//    	return String.format("t.id in %s and", result);
//    }
//
//    /** Build where clause for z layers. */
//    private static String sqlifyTraceZRange(final String sqlFormat, final int zStart, final int zEnd) {
//    	if (zStart >= zEnd) {
//    		return "";
//    	}
//    	return String.format(sqlFormat, zStart, zEnd);
//    }
}
